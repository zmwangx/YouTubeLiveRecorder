#!/usr/bin/env python3

import enum
import json
import html
import logging
import multiprocessing
import os
import platform
import queue
import re
import shlex
import sys
import subprocess
import tempfile
import threading
import time

import humanize
import psutil
from PyQt5.QtCore import (
    Qt,
    QObject,
    QSettings,
    QThread,
    QUrl,
    QTimer,
    pyqtSignal,
    pyqtSlot,
)
from PyQt5.QtGui import (
    QDesktopServices,
    QIcon,
    QTextCursor,
    QTextOption,
)
from PyQt5.QtWidgets import (
    QAction,
    QApplication,
    QCheckBox,
    QComboBox,
    QDialog,
    QFileDialog,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QLayout,
    QLineEdit,
    QMainWindow,
    QMessageBox,
    QPushButton,
    QSizePolicy,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)


APP_AUTHOR = 'Zhiming Wang'
APP_AUTHOR_DOMAIN = 'zhimingwang.org'
APP_NAME = 'YouTubeLiveRecorder'
APP_VERSION = 'v0.1a9'
APP_TITLE = 'YouTube Live Recorder %s' % APP_VERSION
ABOUT = '''
<b>YouTube Live Recorder</b> {appVersion}
<hr>
Author: <a href="https://github.com/zmwangx">Zhiming Wang</a><br>
Contact: <a href="mailto:zmwangx@gmail.com">zmwangx@gmail.com</a><br>
License: <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GPLv3</a><br>
Source: <a href="https://github.com/zmwangx/YouTubeLiveRecorder">https://git.io/YTLR</a><br>
Bug reports:
<a href="https://github.com/zmwangx/YouTubeLiveRecorder/issues">https://git.io/YTLR-bugs</a>
<hr>
youtube-dl version: {{ytdlVersion}}<br>
FFmpeg version: {{ffmpegVersion}}
'''.format(appVersion=APP_VERSION)

ASSETS_DIR = os.path.join(sys._MEIPASS if hasattr(sys, '_MEIPASS') else  # noqa; pylint: disable=no-member,protected-access
                          os.path.dirname(os.path.abspath(__file__)), 'assets')
APP_ICON_PATH = os.path.join(ASSETS_DIR, 'icon-1024.png')

app = QApplication(sys.argv)
app.setOrganizationName(APP_AUTHOR)
app.setOrganizationDomain(APP_AUTHOR_DOMAIN)
app.setApplicationName(APP_NAME)
app.setWindowIcon(QIcon(APP_ICON_PATH))

LOGGING_FORMATTER_OPTIONS = dict(
    fmt='%(asctime)s [%(levelname)s] %(message)s',
    datefmt='%H:%M:%S',
)

WINDOWS = platform.system() == 'Windows'

DEFAULT_DOWNLOADS_DIR = os.path.expanduser(r'~\Downloads' if WINDOWS else '~/Downloads')

NOT_READY = object()


class Config(object):

    def __init__(self):
        self.liveUrl = ''
        self.downloadsDir = DEFAULT_DOWNLOADS_DIR
        self.outputFile = ''
        self.overwrite = False
        self.ffmpegOptions = dict(
            logLevel='info',
            showChunkUrls=False,
        )


# Fix subprocess popups when running pyinstaller-generated exe on Windows.
# https://github.com/pyinstaller/pyinstaller/wiki/Recipe-subprocess
def subprocess_startupinfo():
    if WINDOWS and hasattr(subprocess, 'STARTUPINFO'):
        si = subprocess.STARTUPINFO
        si.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        return si
    else:
        return None


def standard_subprocess_kwargs():
    return dict(
        bufsize=1,
        universal_newlines=True,
        encoding='utf-8',
        errors='backslashreplace',
        startupinfo=subprocess_startupinfo(),
    )


class MainWindow(QMainWindow):

    recordingInitiated = pyqtSignal(str, str, bool, dict)
    recordingCanceled = pyqtSignal()

    def __init__(self):
        super().__init__()

        self.thread = QThread()
        self.worker = Worker(self)

        self.initUI()
        self.initDefaults()
        self.initSignals()

        self.checkDeps()

        self.worker.moveToThread(self.thread)
        self.thread.start()

        self.aboutWindow = None
        self.configureWindow = None

    def initUI(self):
        self.resize(500, 400)
        self.setMinimumSize(400, 250)
        self.setWindowTitle(APP_TITLE)

        self.settings = QSettings()
        self.restoreGeometry(self.settings.value('geometry', b''))
        self.restoreState(self.settings.value('windowState', b''))

        self.statusBar().setStyleSheet('border-top: 1px solid #bbb; font-family: monospaced')
        self.recordingStartTime = None
        self.recordingOutputFile = None
        self.lastRecordedFile = None
        self.recordingTimer = None
        self.updateStatusMessage()

        openAboutWindowAction = QAction('&About', self)
        openAboutWindowAction.triggered.connect(self.openAboutWindow)

        openConfigureWindowAction = QAction('&Configure...', self)
        openConfigureWindowAction.setShortcut('Ctrl+,')
        openConfigureWindowAction.triggered.connect(self.openConfigureWindow)

        recordAction = QAction('&Record', self)
        recordAction.setShortcut('Ctrl+R')
        recordAction.triggered.connect(self.initiateRecording)

        stopAction = QAction('&Stop', self)
        stopAction.setShortcut('Ctrl+S')
        stopAction.triggered.connect(self.cancelRecording)

        openFileAction = QAction('&Open recorded file', self)
        openFileAction.setShortcut('Ctrl+O')
        openFileAction.triggered.connect(self.openRecordedFile)

        revealFileAction = QAction('&Reveal recorded file in folder', self)
        revealFileAction.setShortcut('Alt+Ctrl+O')
        revealFileAction.triggered.connect(self.revealRecordedFile)

        copyLogsAction = QAction('&Copy logs to clipboard', self)
        copyLogsAction.triggered.connect(self.copyLogs)

        clearLogsAction = QAction('&Clear the logs buffer', self)
        clearLogsAction.setShortcut('Ctrl+K')
        clearLogsAction.triggered.connect(self.clearLogs)

        menubar = self.menuBar()

        configurationMenu = menubar.addMenu('&Configuration')
        configurationMenu.addAction(openAboutWindowAction)
        configurationMenu.addAction(openConfigureWindowAction)

        fileMenu = menubar.addMenu('&File')
        fileMenu.addAction(recordAction)
        fileMenu.addAction(stopAction)
        fileMenu.addSeparator()
        fileMenu.addAction(openFileAction)
        fileMenu.addAction(revealFileAction)

        editMenu = menubar.addMenu('&Edit')
        editMenu.addAction(copyLogsAction)
        editMenu.addAction(clearLogsAction)

        urlInputLabel = QLabel('Live URL:')
        urlInputBox = QLineEdit(self, placeholderText='Ex: https://youtube.com/ChinaSNH48/live')

        outputFileInputLabel = QLabel('Output file:')
        outputFileInputBox = QLineEdit(
            self, placeholderText='Auto-determined by youtube-dl if left blank.', readOnly=True)
        outputFileClearButton = QPushButton('Clear', maximumWidth=75)
        outputFileSelector = QPushButton('Select', maximumWidth=75)

        overwriteLabel = QLabel('Overwrite:')
        overwriteCheckbox = QCheckBox('(Overwrite if output file exists.)',
                                      styleSheet='color: gray')

        recordButton = QPushButton('Record', maximumWidth=150, focusPolicy=Qt.NoFocus)
        stopButton = QPushButton('Stop', maximumWidth=150, enabled=False, focusPolicy=Qt.NoFocus)

        buttonsLineLayout = QHBoxLayout()
        buttonsLineLayout.addWidget(recordButton)
        buttonsLineLayout.addWidget(stopButton)

        messagesBox = QTextEdit(self, readOnly=True)
        messagesBox.setWordWrapMode(QTextOption.WrapAnywhere)

        mainLayout = QGridLayout(spacing=8)
        mainLayout.addWidget(urlInputLabel, 0, 0)
        mainLayout.addWidget(urlInputBox, 0, 1, 1, 3)
        mainLayout.addWidget(outputFileInputLabel, 1, 0)
        mainLayout.addWidget(outputFileInputBox, 1, 1)
        mainLayout.addWidget(outputFileClearButton, 1, 2)
        mainLayout.addWidget(outputFileSelector, 1, 3)
        mainLayout.addWidget(overwriteLabel, 2, 0)
        mainLayout.addWidget(overwriteCheckbox, 2, 1, 1, 3)
        mainLayout.addLayout(buttonsLineLayout, 3, 0, 1, 4)
        mainLayout.addWidget(messagesBox, 4, 0, 1, 4)

        mainWidget = QWidget(self)
        mainWidget.setLayout(mainLayout)
        self.setCentralWidget(mainWidget)

        outputFileClearButton.clicked.connect(self.clearOutputFile)
        outputFileSelector.clicked.connect(self.selectOutputFile)
        recordButton.clicked.connect(self.initiateRecording)
        stopButton.clicked.connect(self.cancelRecording)

        self.urlInputBox = urlInputBox
        self.outputFileInputBox = outputFileInputBox
        self.overwriteCheckbox = overwriteCheckbox
        self.recordButton = recordButton
        self.stopButton = stopButton
        self.messagesBox = messagesBox

        self.show()

    def initDefaults(self):
        config = Config()
        self.config = config
        settings = self.settings

        config.liveUrl = settings.value('liveUrl', '')
        config.downloadsDir = os.path.normpath(
            settings.value('downloadsDir', DEFAULT_DOWNLOADS_DIR))
        config.outputFile = settings.value('outputFile', '')
        if config.outputFile:
            config.outputFile = settings.value(config.outputFile)
        config.overwrite = settings.value('overwrite', False, type=bool)
        config.ffmpegOptions['logLevel'] = settings.value('ffmpegLogLevel', 'info')
        config.ffmpegOptions['showChunkUrls'] = settings.value('ffmpegShowChunkUrls', False,
                                                               type=bool)

        self.urlInputBox.setText(config.liveUrl)
        self.outputFileInputBox.setText(config.outputFile)
        self.overwriteCheckbox.setChecked(config.overwrite)

    def initSignals(self):
        self.recording = False
        self.recordingInitiated.connect(self.worker.record)
        self.recordingCanceled.connect(self.worker.stop)

    def checkDeps(self):
        self.ytdlVersion = NOT_READY
        self.ffmpegVersion = NOT_READY

        def extractYtdlVersion(stdout):
            version = stdout.strip()
            return version if version else None

        def extractFFmpegVersion(stdout):
            m = re.match(r'^ffmpeg version (?P<version>[^\s]+)', stdout)
            if m:
                return m.group('version')
            else:
                return None

        self.depCheckerThreads = [
            DepChecker(self, 'youtube-dl', ('youtube-dl', '--version'), extractYtdlVersion),
            DepChecker(self, 'ffmpeg', ('ffmpeg', '-version'), extractFFmpegVersion),
        ]
        for thread in self.depCheckerThreads:
            thread.start()

    def closeEvent(self, event):
        self.settings.setValue('geometry', self.saveGeometry())
        self.settings.setValue('windowState', self.saveState())
        super().closeEvent(event)

    @pyqtSlot()
    def openAboutWindow(self):
        if self.aboutWindow is None:
            self.aboutWindow = AboutWindow(self)
        self.aboutWindow.show()
        self.aboutWindow.activateWindow()
        self.aboutWindow.raise_()

    @pyqtSlot()
    def openConfigureWindow(self):
        if self.configureWindow is None:
            self.configureWindow = ConfigureWindow(self)
        self.configureWindow.show()
        self.configureWindow.activateWindow()
        self.configureWindow.raise_()

    @property
    def recordedFile(self):
        if self.recordingOutputFile is not None:
            return self.recordingOutputFile
        elif self.lastRecordedFile is not None:
            return self.lastRecordedFile
        else:
            return None

    @pyqtSlot()
    def openRecordedFile(self):
        file = self.recordedFile
        if file is None:
            QMessageBox.warning(self, 'Warning', 'You have\'t recorded to a file yet.')
        else:
            QDesktopServices.openUrl(QUrl.fromLocalFile(file))

    @pyqtSlot()
    def revealRecordedFile(self):
        # Actually revealing the file seems to require platform-specific code
        # that's just too sketchy, so we just only the directory and call it a
        # day. Ref: https://stackoverflow.com/q/3490336
        file = self.recordedFile
        if file is None:
            QMessageBox.warning(self, 'Warning', 'You have\'t recorded to a file yet.')
        else:
            QDesktopServices.openUrl(QUrl.fromLocalFile(os.path.dirname(file)))

    @pyqtSlot()
    def copyLogs(self):
        app.clipboard().setText(self.messagesBox.document().toPlainText())
        QMessageBox.information(self, 'Info', 'Logs copied to clipboard.')

    @pyqtSlot()
    def clearLogs(self):
        self.messagesBox.clear()

    @pyqtSlot(str, str)
    def setDepVersion(self, dep, version):
        if not version:
            version = None
            QMessageBox.critical(self, 'Critical', 'Cannot find a usable %s.' % dep)
        if dep == 'youtube-dl':
            self.ytdlVersion = version
        elif dep == 'ffmpeg':
            self.ffmpegVersion = version
        else:
            pass

    @pyqtSlot()
    def clearOutputFile(self):
        self.outputFileInputBox.setText('')

    @pyqtSlot()
    def selectOutputFile(self):
        options = QFileDialog.Options() | QFileDialog.DontConfirmOverwrite
        currentFilename = self.outputFileInputBox.text()
        filename, _ = QFileDialog.getSaveFileName(
            self, 'Output file',
            currentFilename if currentFilename else self.config.downloadsDir,
            'MPEG-TS Files (*.ts *.m2t *.m2ts)', options=options)
        if filename:
            self.outputFileInputBox.setText(os.path.normpath(filename))

    @pyqtSlot()
    def initiateRecording(self):
        liveUrl = self.urlInputBox.text()
        if not liveUrl:
            QMessageBox.critical(self, 'Error', 'Live URL is required.')
            return

        outputFile = self.outputFileInputBox.text()
        if os.path.exists(outputFile) and self.overwriteCheckbox.checkState() != Qt.Checked:
            setOverwrite = QMessageBox.question(
                self, 'Overwrite?', 'The file you selected already exists. Overwrite?',
                defaultButton=QMessageBox.No,
            )
            if setOverwrite == QMessageBox.Yes:
                self.overwriteCheckbox.setChecked(True)
            else:
                return

        if not outputFile:
            try:
                os.makedirs(self.config.downloadsDir, exist_ok=True)
            except OSError:
                QMessageBox.critical(
                    self, 'Error',
                    'Cannot create output directory "%s". '
                    'Please change your default downloads directory in your configuration file, '
                    'or select an output file.' % self.config.downloadsDir)
                return
            else:
                # Set outputFile to the output directory, leaving the filename undetermined.
                outputFile = self.config.downloadsDir

        overwrite = self.overwriteCheckbox.checkState() == Qt.Checked

        self.updateStatusMessage()
        self.recordingInitiated.emit(liveUrl, outputFile, overwrite, self.config.ffmpegOptions)
        self.recording = True
        self.recordButton.setEnabled(False)
        self.stopButton.setEnabled(True)

    @pyqtSlot()
    def cancelRecording(self):
        self.recordingCanceled.emit()

    _logMessageStructure = re.compile(
        r'^(?P<time>\d{2}:\d{2}:\d{2}) '
        r'\[(?P<level>CRITICAL|ERROR|WARNING|INFO|DEBUG|NOTSET)\]'
        r'(?P<body>.*)$',
    )

    _levelToColor = dict(
        CRITICAL='red',
        ERROR='red',
        WARNING='orange',
        INFO='green',
        DEBUG='magenta',
    )

    # Returns an array of tuples (type, text) where type is a Printable.*.
    #
    # Assumes the message is a single line (with or without newline).
    @classmethod
    def parseMessage(cls, message):
        m = cls._logMessageStructure.match(message)
        if m:
            time_ = m.group('time')
            level = m.group('level')
            message_body = m.group('body')
            htmltext = ('<span style="color:blue;{font}">{time}</span> '
                        '<span style="color:{levelcolor};{font}"><b>[{level}]</b> {message_body}</span>'  # noqa
                        # Insert a dummy space to force QTextEdit to restore color.
                        '<span style="color:initial;{font}">&nbsp;</span>'.format(
                            time=time_, levelcolor=cls._levelToColor[level], level=level,
                            message_body=html.escape(message_body),
                            font='font-family:Courier',
                        ))
            if message.endswith('\n'):
                return [(Printable.HTML, htmltext), (Printable.PLAIN, '\n')]
            else:
                return [(Printable.HTML, htmltext)]
        else:
            return [(Printable.PLAIN, message)]

    @pyqtSlot(str)
    def printMessage(self, message):
        box = self.messagesBox
        scrollBar = box.verticalScrollBar()

        currentScroll = scrollBar.value()
        # Record whether user scrolled back in order to decide whether
        # to maintain the current scroll position after inserting new
        # content.
        userScrolledBack = currentScroll != scrollBar.maximum()

        # Make sure the cursor is at the end (readOnly does not disable
        # cursor interaction, unfortunately).
        box.moveCursor(QTextCursor.End)
        for type_, text in self.parseMessage(message):
            if type_ == Printable.HTML:
                box.insertHtml(text)
            else:  # Printable.PLAIN
                box.insertPlainText(text)
        box.moveCursor(QTextCursor.End)

        if userScrolledBack:
            scrollBar.setValue(currentScroll)
        else:
            scrollBar.setValue(scrollBar.maximum())

    @pyqtSlot(float, str)
    def handleRecordingStarted(self, startTime, outputFile):
        self.recordingStartTime = startTime
        self.recordingOutputFile = outputFile
        self.recordingTimer = QTimer(self, interval=1000)
        self.recordingTimer.timeout.connect(self.updateStatusMessage)
        self.recordingTimer.start()

    @pyqtSlot()
    def handleRecordingStopped(self):
        self.recording = False
        self.recordingStartTime = None
        if self.recordingOutputFile is not None:
            self.lastRecordedFile = self.recordingOutputFile
        self.recordingOutputFile = None
        if self.recordingTimer is not None:
            self.recordingTimer.stop()
            self.recordingTimer = None
        self.recordButton.setEnabled(True)
        self.stopButton.setEnabled(False)

    @staticmethod
    def formatDuration(duration):
        seconds = int(duration % 60)
        minutes = int(duration / 60) % 60
        hours = int(duration / 3600)
        return f'{hours}:{minutes:02d}:{seconds:02d}'

    @pyqtSlot()
    def updateStatusMessage(self):
        if self.recordingStartTime is None:
            elapsed = 0
        else:
            elapsed = time.time() - self.recordingStartTime
        elapsedStr = self.formatDuration(elapsed)

        message = f'Elapsed: {elapsedStr}'
        if self.recordingOutputFile and os.path.isfile(self.recordingOutputFile):
            sizeStr = humanize.naturalsize(os.path.getsize(self.recordingOutputFile), binary=True)
            message += f', file size: {sizeStr}'

        self.statusBar().showMessage(message)

    @pyqtSlot()
    def cleanUp(self):
        self.recordingCanceled.emit()
        # Wait for recording to stop (max 3 seconds)
        startedWaiting = time.time()
        while self.recording and time.time() - startedWaiting <= 3:
            time.sleep(0.01)
            app.processEvents()
        self.thread.quit()
        for thread in self.depCheckerThreads:
            thread.quit()
        if not self.thread.wait(3000):
            self.thread.terminate()


class AboutWindow(QDialog):

    def __init__(self, mainWindow):
        super().__init__(mainWindow)
        self.mainWindow = mainWindow
        self.initUI()

    def initUI(self):
        self.setWindowTitle('About')

        main = self.mainWindow
        # Wait for dep versions (max 5 seconds)
        startedWaiting = time.time()
        while ((main.ytdlVersion == NOT_READY or main.ffmpegVersion == NOT_READY)
               and time.time() - startedWaiting <= 5):
            time.sleep(0.01)
            app.processEvents()

        errorMessage = '<span style="color:#999">not found or unusable</span>'
        about = ABOUT.format(
            ytdlVersion=main.ytdlVersion if main.ytdlVersion is not None else errorMessage,
            ffmpegVersion=main.ffmpegVersion if main.ffmpegVersion is not None else errorMessage,
        )
        aboutLabel = QLabel(about)
        aboutLabel.setTextFormat(Qt.RichText)
        aboutLabel.setOpenExternalLinks(True)

        layout = QVBoxLayout()
        layout.addWidget(aboutLabel)
        layout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(layout)


class ConfigureWindow(QDialog):

    FFMPEG_LOG_LEVELS = ['quiet', 'panic', 'fatal', 'error', 'warning',
                         'info', 'verbose', 'debug', 'trace']

    def __init__(self, mainWindow):
        super().__init__(mainWindow)
        self.mainWindow = mainWindow
        self.initUI()

    def initUI(self):
        self.setWindowTitle('Preferences')

        urlInfoLabel = QLabel('*Default livestream URL:')
        urlBox = QLineEdit(self, placeholderText='Ex: https://youtube.com/ChinaSNH48/live')

        outputFileInfoLabel = QLabel('*Default output file:')
        outputFileBox = QLineEdit(self, readOnly=True)
        outputFileClearButton = QPushButton('Clear', maximumWidth=75, focusPolicy=Qt.NoFocus)
        outputFileSelector = QPushButton('Select', maximumWidth=75, focusPolicy=Qt.NoFocus)
        outputFileLineLayout = QHBoxLayout()
        outputFileLineLayout.addWidget(outputFileBox)
        outputFileLineLayout.addWidget(outputFileClearButton)
        outputFileLineLayout.addWidget(outputFileSelector)

        downloadsDirInfoLabel = QLabel('Default downloads directory '
                                       '(used when output file is not specified):')
        downloadsDirBox = QLineEdit(self, readOnly=True)
        downloadsDirSelector = QPushButton('Select', maximumWidth=75, focusPolicy=Qt.NoFocus)
        downloadsDirLineLayout = QHBoxLayout()
        downloadsDirLineLayout.addWidget(downloadsDirBox)
        downloadsDirLineLayout.addWidget(downloadsDirSelector)

        overwriteInfoLabel = QLabel('*Overwrite existing file by default:')
        overwriteCheckbox = QCheckBox()
        overwriteLineLayout = QHBoxLayout()
        overwriteLineLayout.addWidget(overwriteInfoLabel)
        overwriteLineLayout.addStretch(1)
        overwriteLineLayout.addWidget(overwriteCheckbox)

        def newHorizontalRule():
            rule = QWidget(styleSheet='background: #bbb')
            rule.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
            rule.setFixedHeight(1)
            return rule

        horizontalRule1 = newHorizontalRule()

        caveatsLabel = QLabel('Note: Setting items marked with asterisks '
                              'are only applied after you restart the application.',
                              styleSheet='color: gray', wordWrap=True)

        horizontalRule2 = newHorizontalRule()

        ffmpegOptionsHeadingLabel = QLabel('FFmpeg options (advanced)',
                                           styleSheet='font-weight: bold')

        ffmpegLogLevelInfoLabel = QLabel('FFmpeg log level')
        ffmpegLogLevelDropdown = QComboBox()
        ffmpegLogLevelDropdown.setSizeAdjustPolicy(QComboBox.AdjustToContents)
        ffmpegLogLevelDropdown.addItems(self.FFMPEG_LOG_LEVELS)
        ffmpegLogLevelLineLayout = QHBoxLayout()
        ffmpegLogLevelLineLayout.addWidget(ffmpegLogLevelInfoLabel)
        ffmpegLogLevelLineLayout.addStretch(1)
        ffmpegLogLevelLineLayout.addWidget(ffmpegLogLevelDropdown)

        ffmepgShowChunkUrlsInfoLabel = QLabel('Show chunk URLs '
                                              '(only affects the "info" log level)')
        ffmepgShowChunkUrlsCheckbox = QCheckBox()
        ffmpegShowChunkUrlsLineLayout = QHBoxLayout()
        ffmpegShowChunkUrlsLineLayout.addWidget(ffmepgShowChunkUrlsInfoLabel)
        ffmpegShowChunkUrlsLineLayout.addStretch(1)
        ffmpegShowChunkUrlsLineLayout.addWidget(ffmepgShowChunkUrlsCheckbox)

        horizontalRule3 = newHorizontalRule()

        saveButton = QPushButton('Save', minimumWidth=90, default=True)
        revertButton = QPushButton('Revert', minimumWidth=90, focusPolicy=Qt.NoFocus)
        cancelButton = QPushButton('Cancel', minimumWidth=90, focusPolicy=Qt.NoFocus)
        actionBarLayout = QHBoxLayout()
        actionBarLayout.addStretch(1)
        actionBarLayout.addWidget(saveButton)
        actionBarLayout.addWidget(revertButton)
        actionBarLayout.addWidget(cancelButton)

        mainLayout = QVBoxLayout()
        mainLayout.addWidget(urlInfoLabel)
        mainLayout.addWidget(urlBox)
        mainLayout.addWidget(outputFileInfoLabel)
        mainLayout.addLayout(outputFileLineLayout)
        mainLayout.addWidget(downloadsDirInfoLabel)
        mainLayout.addLayout(downloadsDirLineLayout)
        mainLayout.addLayout(overwriteLineLayout)
        mainLayout.addWidget(horizontalRule1)
        mainLayout.addWidget(ffmpegOptionsHeadingLabel)
        mainLayout.addLayout(ffmpegLogLevelLineLayout)
        mainLayout.addLayout(ffmpegShowChunkUrlsLineLayout)
        mainLayout.addWidget(horizontalRule2)
        mainLayout.addWidget(caveatsLabel)
        mainLayout.addWidget(horizontalRule3)
        mainLayout.addLayout(actionBarLayout)
        mainLayout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(mainLayout)

        outputFileClearButton.clicked.connect(self.clearOutputFile)
        outputFileSelector.clicked.connect(self.selectOutputFile)
        downloadsDirSelector.clicked.connect(self.selectDownloadsDir)
        saveButton.clicked.connect(self.save)
        revertButton.clicked.connect(self.revert)
        cancelButton.clicked.connect(self.hide)

        self.urlBox = urlBox
        self.outputFileBox = outputFileBox
        self.downloadsDirBox = downloadsDirBox
        self.overwriteCheckbox = overwriteCheckbox
        self.ffmpegLogLevelDropdown = ffmpegLogLevelDropdown
        self.ffmepgShowChunkUrlsCheckbox = ffmepgShowChunkUrlsCheckbox

    # Revert to saved values on show
    @pyqtSlot()
    def show(self):
        self.revert()
        super().show()

    @pyqtSlot()
    def revert(self):
        config = self.mainWindow.config
        self.urlBox.setText(config.liveUrl)
        self.outputFileBox.setText(config.outputFile)
        self.downloadsDirBox.setText(config.downloadsDir)
        self.overwriteCheckbox.setChecked(config.overwrite)
        self.ffmpegLogLevelDropdown.setCurrentText(config.ffmpegOptions['logLevel'])
        self.ffmepgShowChunkUrlsCheckbox.setChecked(config.ffmpegOptions['showChunkUrls'])

    @pyqtSlot()
    def save(self):
        config = self.mainWindow.config
        config.liveUrl = self.urlBox.text()
        config.outputFile = self.outputFileBox.text()
        config.downloadsDir = self.downloadsDirBox.text()
        config.overwrite = self.overwriteCheckbox.checkState() == Qt.Checked
        config.ffmpegOptions['logLevel'] = self.ffmpegLogLevelDropdown.currentText()
        config.ffmpegOptions['showChunkUrls'] = (
            self.ffmepgShowChunkUrlsCheckbox.checkState() == Qt.Checked)

        settings = self.mainWindow.settings
        settings.setValue('liveUrl', config.liveUrl)
        settings.setValue('outputFile', config.outputFile)
        settings.setValue('downloadsDir', config.downloadsDir)
        settings.setValue('overwrite', config.overwrite)
        settings.setValue('ffmpegLogLevel', config.ffmpegOptions['logLevel'])
        settings.setValue('ffmpegShowChunkUrls', config.ffmpegOptions['showChunkUrls'])

        self.hide()

    @pyqtSlot()
    def clearOutputFile(self):
        self.outputFileBox.setText('')

    @pyqtSlot()
    def selectOutputFile(self):
        options = QFileDialog.Options() | QFileDialog.DontConfirmOverwrite
        currentFilename = self.outputFileBox.text()
        filename, _ = QFileDialog.getSaveFileName(
            self, 'Default output file',
            currentFilename if currentFilename else self.downloadsDirBox.text(),
            'MPEG-TS Files (*.ts *.m2t *.m2ts)', options=options)
        if filename:
            self.outputFileBox.setText(os.path.normpath(filename))

    @pyqtSlot()
    def selectDownloadsDir(self):
        options = (QFileDialog.Options() | QFileDialog.ShowDirsOnly |
                   QFileDialog.DontResolveSymlinks)
        currentDir = self.downloadsDirBox.text()
        dirname = QFileDialog.getExistingDirectory(
            self, 'Default downloads directory', currentDir, options=options)
        if dirname:
            self.downloadsDirBox.setText(os.path.normpath(dirname))


class DepChecker(QThread):

    depChecked = pyqtSignal(str, str)

    def __init__(self, gui, dep, command, outputProcessor):
        super().__init__()
        self.gui = gui
        self.dep = dep
        self.command = command
        self.outputProcessor = outputProcessor
        self.initSignals()

    def initSignals(self):
        self.depChecked.connect(self.gui.setDepVersion)

    def sendVersion(self, version):
        self.depChecked.emit(self.dep, '' if version is None else version)

    def run(self):
        try:
            proc = subprocess.Popen(
                self.command,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                **standard_subprocess_kwargs(),
            )
        except (OSError, subprocess.SubprocessError):
            self.sendVersion(None)
            return

        try:
            stdout, _ = proc.communicate(5)
        except subprocess.TimeoutExpired:
            proc.kill()

        if proc.returncode != 0:
            self.sendVersion(None)
            return

        version = self.outputProcessor(stdout)
        self.sendVersion(version)


class Worker(QObject):

    newMessage = pyqtSignal(str)
    recordingStarted = pyqtSignal(float, str)
    recordingStopped = pyqtSignal()

    def __init__(self, gui):
        super().__init__()
        self.gui = gui
        self.initSignals()
        self.initLogger()

    def initSignals(self):
        self.newMessage.connect(self.gui.printMessage)
        self.recordingStarted.connect(self.gui.handleRecordingStarted)
        self.recordingStopped.connect(self.gui.handleRecordingStopped)

    def initLogger(self):
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)
        handler = SignalEmittingHandler(self.newMessage)
        handler.setFormatter(logging.Formatter(**LOGGING_FORMATTER_OPTIONS))
        self.logger.addHandler(handler)

    @pyqtSlot(str, str, bool, dict)
    def record(self, liveUrl, outputFile, overwrite, ffmpegOptions):
        self.newMessage.emit('=' * 30 + '\n')
        self.logger.info('Recording initiated: %s', liveUrl)
        self.logger.info('Recording to %s: %s (%s)',
                         'directory' if os.path.isdir(outputFile) else 'file', outputFile,
                         'overwrite if exists' if overwrite else 'never overwrite')

        connRecv, connSend = multiprocessing.Pipe()
        recorder = RecorderProcess(liveUrl, outputFile, overwrite, ffmpegOptions, connSend)
        recorder.start()

        self.interrupted = False
        while not self.interrupted:
            while connRecv.poll():
                obj = connRecv.recv()
                if isinstance(obj, RecorderEvent):
                    if obj.type == RecorderEvent.RECORDING_STARTED:
                        self.recordingStarted.emit(
                            obj.payload['start_time'],
                            obj.payload['output_file'],
                        )
                else:
                    self.newMessage.emit(obj)
            if not recorder.is_alive():
                break
            app.processEvents()
            time.sleep(0.01)

        if recorder.is_alive():
            # Interrupted by a signal.
            self.logger.warning('Recording interrupted')

            # Use psutil to kill the entire proc tree in a cross-platform way.
            # Credit: https://stackoverflow.com/a/4229404
            # https://psutil.readthedocs.io/en/latest/#kill-process-tree
            parent = psutil.Process(recorder.pid)
            procs = parent.children(recursive=True)
            procs.append(parent)
            for proc in procs:
                proc.terminate()
            _, alive = psutil.wait_procs(procs, timeout=1)
            for proc in alive:
                proc.kill()
        else:
            # Worker process finished.
            if recorder.exitcode == 0:
                self.logger.info('Recording finished')
            else:
                self.logger.error('Recording failed')
        self.newMessage.emit('=' * 30 + '\n\n')

        recorder.join(0.5)
        self.recordingStopped.emit()

    @pyqtSlot()
    def stop(self):
        self.interrupted = True


# We use snake case for the Qt-free part. Camel case is gross.
class RecorderProcess(multiprocessing.Process):

    # If output_file is a directory, let youtube-dl determine the filename.
    # conn is the sending end of a multiprocessing.Pipe.
    def __init__(self, live_url, output_file, overwrite, ffmpeg_options, conn):
        super().__init__()
        self.live_url = live_url
        self.output_file = output_file
        self.overwrite = overwrite
        self.log_level = ffmpeg_options['logLevel']
        self.hide_chunk_urls = self.log_level == 'info' and not ffmpeg_options['showChunkUrls']
        self.conn = conn
        self.init_logger()

    def init_logger(self):
        self.logger = PipingLogger(self.conn, level=logging.INFO, **LOGGING_FORMATTER_OPTIONS)

    def run(self):
        stream_url, auto_filename_no_ext = self.fetch_stream_info(self.live_url)
        if os.path.isdir(self.output_file):
            self.output_file = os.path.join(self.output_file, '%s.ts' % auto_filename_no_ext)

        self.logger.info('Output file: %s', self.output_file)
        self.record_stream(stream_url, self.output_file, overwrite=self.overwrite)

        self.conn.close()

    def log_command(self, cmd):
        msg = ' '.join(shlex.quote(arg) for arg in cmd)
        msg = msg.replace('%', '%%')
        self.logger.info(msg)

    # Handle output streams (stdout, stderr, or combined) of a
    # subprocess in real time, line by line, to depletion.
    #
    # The subprocess should be opened with bufsize=1 and
    # universal_newlines=True (text mode, line buffered).
    #
    # Credit: https://stackoverflow.com/a/4896288
    def handle_output(self, process, streams, handlers):
        def queue_up_read(fp, queue_):
            for line in fp:
                queue_.put(line)

        output_queues = [queue.Queue() for _ in streams]
        output_reader_threads = [threading.Thread(
            target=queue_up_read,
            args=(stream, output_queue),
            daemon=True,
        ) for stream, output_queue in zip(streams, output_queues)]
        for thread in output_reader_threads:
            thread.start()

        while process.poll() is None:
            no_output = True
            for output_queue, handler in zip(output_queues, handlers):
                try:
                    line = output_queue.get_nowait()
                except queue.Empty:
                    pass
                else:
                    no_output = False
                    handler(line)
            if no_output:
                time.sleep(0.01)

        # Process finished. Process remaining output.
        for output_queue, handle in zip(output_queues, handlers):
            while True:
                try:
                    line = output_queue.get_nowait()
                except queue.Empty:
                    break
                else:
                    handle(line)

    def fetch_stream_info(self, live_url):
        ytdl_cmd = ['youtube-dl', '--dump-json', '--youtube-skip-dash-manifest', live_url]
        self.log_command(ytdl_cmd)
        try:
            ytdl_process = None
            ytdl_process = subprocess.Popen(
                ytdl_cmd,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                **standard_subprocess_kwargs(),
            )
            ytdl_stdout_lines = []
            self.handle_output(ytdl_process, (ytdl_process.stdout, ytdl_process.stderr),
                               (ytdl_stdout_lines.append, self.conn.send))
            json_output = ''.join(ytdl_stdout_lines)
        except (OSError, subprocess.SubprocessError):
            if not ytdl_process:
                self.logger.error('Failed to start youtube-dl')
                sys.exit(1)
        if ytdl_process.returncode != 0:
            self.logger.error('youtube-dl failed with exit status %d', ytdl_process.returncode)
            sys.exit(1)

        try:
            metadata = json.loads(json_output)
        except json.JSONDecodeError as err:
            fd, path = tempfile.mkstemp()
            with os.fdopen(fd, 'w') as fp:
                fp.write(json_output)
            self.logger.error('Failed to decode JSON output: %s', err)
            self.logger.error('Response recorded to %s', path)
            sys.exit(1)

        try:
            if not metadata['is_live']:
                # Refuse to download a non-livestream.
                self.logger.error('Not a livestream.')
                sys.exit(1)
            format_id = metadata['format_id']
            for stream in metadata['formats']:
                if stream['format_id'] == format_id:
                    stream_url = stream['url']
                    protocol = stream['protocol']
                    if protocol != 'm3u8':
                        self.logger.warning('Unsupported protocol %s', protocol)
                    break
            else:
                self.logger.error('Format %s not found', format_id)
                sys.exit(1)
            auto_filename = metadata['_filename']
            auto_filename_no_ext = os.path.splitext(os.path.basename(auto_filename))[0]
        except (TypeError, KeyError):
            fd, path = tempfile.mkstemp()
            with os.fdopen(fd, 'w') as fp:
                fp.write(json_output)
            self.logger.error('JSON output does not contain the necessary information')
            self.logger.error('Response recorded to %s', path)
            sys.exit(1)

        return stream_url, auto_filename_no_ext

    CHUNK_URL_LINE_PATTERN = re.compile(r'(^|(?<=[\n\r]))\[.*?\] '
                                        r'Opening \'https://[^.]+\.googlevideo\.com/[^\']+\''
                                        r'.*?[\r\n]')

    def record_stream(self, stream_url, output_file, overwrite=False):
        try:
            output_dir = os.path.dirname(output_file)
            os.makedirs(output_dir, exist_ok=True)
        except OSError:
            self.logger.error('Failed to create directory "%s"' % output_dir)
            sys.exit(1)

        ffmpeg_cmd = ['ffmpeg', '-loglevel', self.log_level, '-i', stream_url, '-c', 'copy',
                      '-f', 'mpegts', '-y' if overwrite else '-n', output_file]
        self.log_command(ffmpeg_cmd)
        try:
            ffmpeg_process = None
            ffmpeg_process = subprocess.Popen(
                ffmpeg_cmd,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                **standard_subprocess_kwargs(),
            )

            self.conn.send(RecorderEvent(RecorderEvent.RECORDING_STARTED, dict(
                start_time=time.time(),
                output_file=self.output_file,
            )))

            if self.hide_chunk_urls:
                def output_handler(line):
                    self.conn.send(self.CHUNK_URL_LINE_PATTERN.sub('', line))
            else:
                output_handler = self.conn.send

            self.handle_output(ffmpeg_process, (ffmpeg_process.stdout,), (output_handler,))
        except (OSError, subprocess.SubprocessError):
            if not ffmpeg_process:
                self.logger.error('Failed to start ffmpeg')
                sys.exit(1)
        if ffmpeg_process.returncode != 0:
            self.logger.error('ffmpeg failed with exit status %d', ffmpeg_process.returncode)
            sys.exit(1)


class RecorderEvent(object):

    # Event types
    RECORDING_STARTED = 0

    def __init__(self, type_, payload=None):
        self.type = type_
        self.payload = payload


class Printable(enum.Enum):
    PLAIN = 0
    HTML = 1


class SignalEmittingHandler(logging.Handler):

    # signal is a Worker.newMessage singal.
    def __init__(self, signal):
        super().__init__()
        self.signal = signal

    def emit(self, record):
        self.signal.emit(self.format(record) + '\n')


# A basic mock logger used in a RecorderProcess.
#
# We cannot use an actual logger (regardless of name passed to
# logging.getLogger), since on macOS, using the logger (e.g. calling
# logger.info) inside the forked process causes an error:
#
#   The process has forked and you cannot use this CoreFoundation functionality safely. You MUST exec().  # noqa
#   Break on __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__() to debug.  # noqa
#
# Possibly due to root logger interactions (just my guess).

class PipingLogger(object):

    _levelToName = {
        logging.CRITICAL: 'CRITICAL',
        logging.ERROR: 'ERROR',
        logging.WARNING: 'WARNING',
        logging.INFO: 'INFO',
        logging.DEBUG: 'DEBUG',
        logging.NOTSET: 'NOTSET',
    }

    # conn is the sending end of a multiprocessing.Pipe.
    #
    # fmt and datefmt are the same as the arguments to the logging.Formatter
    # constructor, except fmt only supports the %-style, and the following
    # attributes: asctime, levelname, and message.
    def __init__(self, conn, level=logging.INFO, fmt='', datefmt=''):
        self.conn = conn
        self.level = level
        self.fmt = fmt
        self.datefmt = datefmt

    def debug(self, msg, *args, **kwargs):
        self.log(logging.DEBUG, msg, *args, **kwargs)

    def info(self, msg, *args, **kwargs):
        self.log(logging.INFO, msg, *args, **kwargs)

    def warning(self, msg, *args, **kwargs):
        self.log(logging.WARNING, msg, *args, **kwargs)

    def error(self, msg, *args, **kwargs):
        self.log(logging.ERROR, msg, *args, **kwargs)

    def critical(self, msg, *args, **kwargs):
        self.log(logging.CRITICAL, msg, *args, **kwargs)

    # kwargs are ignored.
    def log(self, level, msg, *args, **kwargs):
        # pylint: disable=unused-argument
        if level < self.level:
            return
        record = dict(
            asctime=time.strftime(self.datefmt),
            levelname=self._levelToName.get(level, 'UNKNOWN'),
            message=msg % args,
        )
        self.conn.send((self.fmt % record) + '\n')


if __name__ == '__main__':
    multiprocessing.freeze_support()
    window = MainWindow()
    app.aboutToQuit.connect(window.cleanUp)
    sys.exit(app.exec_())
