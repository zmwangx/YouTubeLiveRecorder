#!/usr/bin/env python3

import configparser
import enum
import json
import html
import logging
import multiprocessing
import os
import platform
import queue
import re
import shlex
import sys
import subprocess
import tempfile
import threading
import time

import appdirs
import psutil
from PyQt5.QtCore import (
    Qt,
    QObject,
    QSettings,
    QThread,
    QUrl,
    pyqtSignal,
    pyqtSlot,
)
from PyQt5.QtGui import (
    QDesktopServices,
    QTextCursor,
    QTextOption,
)
from PyQt5.QtWidgets import (
    QApplication,
    QCheckBox,
    QFileDialog,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QMainWindow,
    QMessageBox,
    QPushButton,
    QTextEdit,
    QWidget,
)


APP_AUTHOR = 'Zhiming Wang'
APP_AUTHOR_DOMAIN = 'zhimingwang.org'
APP_NAME = 'YouTubeLiveRecorder'
APP_VERSION = 'v0.1a2'
APP_TITLE = 'YouTube Live Recorder %s' % APP_VERSION

app = QApplication(sys.argv)
app.setOrganizationName(APP_AUTHOR)
app.setOrganizationDomain(APP_AUTHOR_DOMAIN)
app.setApplicationName(APP_NAME)

LOGGING_FORMATTER_OPTIONS = dict(
    fmt='%(asctime)s [%(levelname)s] %(message)s',
    datefmt='%H:%M:%S',
)

WINDOWS = platform.system() == 'Windows'
DEFAULT_DOWNLOADS_DIR = '~\Downloads' if WINDOWS else '~/Downloads'
SAMPLE_CONFIG_FILE = '''\
[DEFAULT]
# URL of a YouTube livestream, e.g., https://youtube.com/ChinaSNH48/live.
live_url =

# Default output directory when you don't specify an output file. Must
# be an absolute path. Supports tilde expansion (i.e., leading ~ is
# expanded to your home directory).
downloads_dir = {default_downloads_dir}

# Default output file. If a relative path is given, it is considered
# relative to the default downloads directory. Also supports tilde
# expansion.
output_file =

# Whether to overwrite an existing file. Default is no.
overwrite = no
'''.format(default_downloads_dir=DEFAULT_DOWNLOADS_DIR)


class Config(object):
    configFile = ''
    liveUrl = ''
    downloadsDir = os.path.expanduser('~/Downloads')
    outputFile = ''
    overwrite = False


# Raises configparser.Error when config file is corrupted.
def loadConfig():
    configDir = appdirs.user_config_dir(APP_NAME)
    os.makedirs(configDir, exist_ok=True)
    configFile = os.path.join(configDir, 'defaults.ini')
    Config.configFile = configFile

    if not os.path.exists(configFile):
        with open(configFile, 'w') as fp:
            fp.write(SAMPLE_CONFIG_FILE)

    config = configparser.ConfigParser()
    with open(configFile) as fp:
        config.read_file(fp)

    Config.liveUrl = config.get('DEFAULT', 'live_url', fallback='')
    Config.downloadsDir = config.get('DEFAULT', 'downloads_dir', fallback='')
    if not os.path.isabs(Config.downloadsDir):
        Config.downloadsDir = os.path.expanduser(DEFAULT_DOWNLOADS_DIR)
    Config.outputFile = config.get('DEFAULT', 'output_file', fallback='')
    if Config.outputFile and not os.path.isabs(Config.outputFile):
        Config.outputFile = os.path.join(Config.downloadsDir, Config.outputFile)
    Config.overwrite = config.getboolean('DEFAULT', 'overwrite', fallback=False)


# Fix subprocess popups when running pyinstaller-generated exe on Windows.
# https://github.com/pyinstaller/pyinstaller/wiki/Recipe-subprocess
def subprocess_startupinfo():
    if WINDOWS and hasattr(subprocess, 'STARTUPINFO'):
        si = subprocess.STARTUPINFO
        si.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        return si
    else:
        return None


def standard_subprocess_kwargs():
    return dict(
        bufsize=1,
        universal_newlines=True,
        encoding='utf-8',
        errors='backslashreplace',
        startupinfo=subprocess_startupinfo(),
    )


class MainWindow(QMainWindow):

    recordingInitiated = pyqtSignal(str, str, bool)
    recordingCanceled = pyqtSignal()

    def __init__(self):
        super().__init__()

        self.thread = QThread()
        self.worker = Worker(self)

        self.initUI()
        self.initDefaults()
        self.initSignals()

        self.checkDependency('youtube-dl')
        self.checkDependency('ffmpeg')

        self.worker.moveToThread(self.thread)
        self.thread.start()

    def initUI(self):
        self.resize(500, 400)
        self.setMinimumSize(400, 250)

        self.settings = QSettings()
        self.restoreGeometry(self.settings.value('geometry', b''))
        self.restoreState(self.settings.value('windowState', b''))

        self.setWindowTitle(APP_TITLE)

        urlInputLabel = QLabel('Live URL:')
        urlInputBox = QLineEdit(self, placeholderText='https://youtube.com/ChinaSNH48/live')

        outputFileInputLabel = QLabel('Output file:')
        outputFileInputBox = QLineEdit(
            self, placeholderText='Auto-determined by youtube-dl if left blank.')
        outputFileSelector = QPushButton('Select', maximumWidth=75)

        overwriteLabel = QLabel('Overwrite:')
        overwriteCheckbox = QCheckBox('(Overwrite if output file exists.)',
                                      styleSheet='color: gray')

        recordButton = QPushButton('Record', maximumWidth=150)
        stopButton = QPushButton('Stop', maximumWidth=150, enabled=False)

        buttonsLineLayout = QHBoxLayout()
        buttonsLineLayout.addWidget(recordButton)
        buttonsLineLayout.addWidget(stopButton)

        messagesBox = QTextEdit(self, readOnly=True, styleSheet='font-family: monospaced')
        messagesBox.setWordWrapMode(QTextOption.WrapAnywhere)

        configurationInfoLabel = QLabel('Customize your defaults by editing the configuration file:')
        configurationOpenButton = QPushButton('Open', maximumWidth=75)

        configurationLineLayout = QHBoxLayout()
        configurationLineLayout.setContentsMargins(0, 0, 0, 0)
        configurationLineLayout.addWidget(configurationInfoLabel)
        configurationLineLayout.addWidget(configurationOpenButton)

        mainLayout = QGridLayout(spacing=8)
        mainLayout.setContentsMargins(15, 15, 15, 5)  # Reduce bottom margin
        mainLayout.addWidget(urlInputLabel, 0, 0)
        mainLayout.addWidget(urlInputBox, 0, 1, 1, 2)
        mainLayout.addWidget(outputFileInputLabel, 1, 0)
        mainLayout.addWidget(outputFileInputBox, 1, 1)
        mainLayout.addWidget(outputFileSelector, 1, 2)
        mainLayout.addWidget(overwriteLabel, 2, 0)
        mainLayout.addWidget(overwriteCheckbox, 2, 1)
        mainLayout.addLayout(buttonsLineLayout, 3, 0, 1, 3)
        mainLayout.addWidget(messagesBox, 4, 0, 1, 3)
        mainLayout.addLayout(configurationLineLayout, 5, 0, 1, 3)

        mainWidget = QWidget(self)
        mainWidget.setLayout(mainLayout)
        self.setCentralWidget(mainWidget)

        outputFileSelector.clicked.connect(self.selectOutputFile)
        recordButton.clicked.connect(self.initiateRecording)
        stopButton.clicked.connect(self.cancelRecording)
        configurationOpenButton.clicked.connect(self.openConfigFile)

        self.urlInputBox = urlInputBox
        self.outputFileInputBox = outputFileInputBox
        self.overwriteCheckbox = overwriteCheckbox
        self.recordButton = recordButton
        self.stopButton = stopButton
        self.messagesBox = messagesBox
        self.configurationOpenButton = configurationOpenButton

        self.show()

    def initDefaults(self):
        try:
            loadConfig()
        except configparser.Error:
            QMessageBox.warning(self, 'Warning',
                                ('Configuration file "%s" is corrupted '
                                 'and has been moved to a backup.' % Config.configFile))
            try:
                os.replace(Config.configFile, '%s.bak' % Config.configFile)
            except OSError:
                try:
                    os.remove(Config.configFile)
                except OSError:
                    pass
            # Write and load the default config
            loadConfig()

        self.urlInputBox.setText(Config.liveUrl)
        self.outputFileInputBox.setText(Config.outputFile)
        self.overwriteCheckbox.setChecked(Config.overwrite)

    def initSignals(self):
        self.recording = False
        self.recordingInitiated.connect(self.worker.record)
        self.recordingCanceled.connect(self.worker.stop)

    def checkDependency(self, executable):
        try:
            proc = subprocess.Popen(
                executable,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                **standard_subprocess_kwargs(),
            )
            proc.kill()
        except (OSError, subprocess.SubprocessError):
            QMessageBox.critical(self, 'Critical', 'Cannot find a usable %s.' % executable)

    def closeEvent(self, event):
        self.settings.setValue('geometry', self.saveGeometry())
        self.settings.setValue('windowState', self.saveState())
        super().closeEvent(event)

    @pyqtSlot()
    def selectOutputFile(self):
        options = QFileDialog.Options() | QFileDialog.DontConfirmOverwrite
        currentFilename = self.outputFileInputBox.text()
        filename, _ = QFileDialog.getSaveFileName(
            self, 'Output file',
            currentFilename if currentFilename else Config.downloadsDir,
            'MPEG-TS Files (*.ts *.m2t *.m2ts)', options=options)
        if filename:
            self.outputFileInputBox.setText(filename)

    @pyqtSlot()
    def initiateRecording(self):
        liveUrl = self.urlInputBox.text()
        if not liveUrl:
            QMessageBox.critical(self, 'Error', 'Live URL is required.')
            return

        outputFile = self.outputFileInputBox.text()
        if os.path.exists(outputFile) and self.overwriteCheckbox.checkState() != Qt.Checked:
            setOverwrite = QMessageBox.question(
                self, 'Overwrite?', 'The file you selected already exists. Overwrite?',
                defaultButton=QMessageBox.No,
            )
            if setOverwrite == QMessageBox.Yes:
                self.overwriteCheckbox.setChecked(True)
            else:
                return

        overwrite = self.overwriteCheckbox.checkState() == Qt.Checked

        self.recordingInitiated.emit(liveUrl, outputFile, overwrite)
        self.recording = True
        self.recordButton.setEnabled(False)
        self.stopButton.setEnabled(True)

    @pyqtSlot()
    def cancelRecording(self):
        self.recordingCanceled.emit()

    _logMessageStructure = re.compile(
        r'^(?P<time>\d{2}:\d{2}:\d{2}) '
        r'\[(?P<level>CRITICAL|ERROR|WARNING|INFO|DEBUG|NOTSET)\]'
        r'(?P<body>.*)$',
    )

    _levelToColor = dict(
        CRITICAL='red',
        ERROR='red',
        WARNING='orange',
        INFO='green',
        DEBUG='magenta',
    )

    # Returns an array of tuples (type, text) where type is a Printable.*.
    #
    # Assumes the message is a single line (with or without newline).
    @classmethod
    def parseMessage(cls, message):
        m = cls._logMessageStructure.match(message)
        if m:
            time = m.group('time')
            level = m.group('level')
            message_body = m.group('body')
            htmltext = ('<span style="color:blue">{time}</span> '
                        '<span style="color:{levelcolor}"><b>[{level}]</b> {message_body}</span>'
                        # Insert a dummy space to force QTextEdit to restore color.
                        '<span style="color:initial">&nbsp;</span>'.format(
                            time=time, levelcolor=cls._levelToColor[level], level=level,
                            message_body=html.escape(message_body),
                        ))
            if message.endswith('\n'):
                return [(Printable.HTML, htmltext), (Printable.PLAIN, '\n')]
            else:
                return [(Printable.HTML, htmltext)]
        else:
            return [(Printable.PLAIN, message)]

    @pyqtSlot(str)
    def printMessage(self, message):
        box = self.messagesBox
        scrollBar = box.verticalScrollBar()

        currentScroll = scrollBar.value()
        # Record whether user scrolled back in order to decide whether
        # to maintain the current scroll position after inserting new
        # content.
        userScrolledBack = currentScroll != scrollBar.maximum()

        # Make sure the cursor is at the end (readOnly does not disable
        # cursor interaction, unfortunately).
        box.moveCursor(QTextCursor.End)
        for type_, text in self.parseMessage(message):
            if type_ == Printable.HTML:
                box.insertHtml(text)
            else:  # Printable.PLAIN
                box.insertPlainText(text)
        box.moveCursor(QTextCursor.End)

        if userScrolledBack:
            scrollBar.setValue(currentScroll)
        else:
            scrollBar.setValue(scrollBar.maximum())


    @pyqtSlot()
    def handleRecordingStopped(self):
        self.recording = False
        self.recordButton.setEnabled(True)
        self.stopButton.setEnabled(False)

    @pyqtSlot()
    def openConfigFile(self):
        QDesktopServices.openUrl(QUrl.fromLocalFile(Config.configFile))

    @pyqtSlot()
    def cleanUp(self):
        self.recordingCanceled.emit()
        # Wait for recording to stop (max 3 seconds)
        started_waiting = time.time()
        while self.recording and time.time() - started_waiting <= 3:
            time.sleep(0.01)
            app.processEvents()
        self.thread.quit()
        if not self.thread.wait(3000):
            self.thread.terminate()


class Worker(QObject):

    newMessage = pyqtSignal(str)
    recordingStopped = pyqtSignal()

    def __init__(self, gui):
        super().__init__()
        self.gui = gui
        self.initSignals()
        self.initLogger()

    def initSignals(self):
        self.newMessage.connect(self.gui.printMessage)
        self.recordingStopped.connect(self.gui.handleRecordingStopped)

    def initLogger(self):
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)
        handler = SignalEmittingHandler(self.newMessage)
        handler.setFormatter(logging.Formatter(**LOGGING_FORMATTER_OPTIONS))
        self.logger.addHandler(handler)

    @pyqtSlot(str, str, bool)
    def record(self, liveUrl, outputFile, overwrite):
        self.newMessage.emit('=' * 30 + '\n')
        self.logger.info('Recording initiated: %s', liveUrl)
        self.logger.info('Recording to file: %s (%s)',
                         outputFile if outputFile else '<auto>',
                         'overwrite if exists' if overwrite else 'never overwrite')

        connRecv, connSend = multiprocessing.Pipe()
        recorder = RecorderProcess(liveUrl, outputFile, overwrite, connSend)
        recorder.start()

        self.interrupted = False
        while not self.interrupted:
            while connRecv.poll():
                message = connRecv.recv()
                self.newMessage.emit(message)
            if not recorder.is_alive():
                break
            app.processEvents()
            time.sleep(0.01)

        if recorder.is_alive():
            # Interrupted by a signal.
            self.logger.warning('Recording interrupted')

            # Use psutil to kill the entire proc tree in a cross-platform way.
            # Credit: https://stackoverflow.com/a/4229404
            # https://psutil.readthedocs.io/en/latest/#kill-process-tree
            parent = psutil.Process(recorder.pid)
            procs = parent.children(recursive=True)
            procs.append(parent)
            for proc in procs:
                proc.terminate()
            gone, alive = psutil.wait_procs(procs, timeout=1)
            for proc in alive:
                proc.kill()
        else:
            # Worker process finished.
            if recorder.exitcode == 0:
                self.logger.info('Recording finished')
            else:
                self.logger.error('Recording failed')
        self.newMessage.emit('=' * 30 + '\n\n')

        recorder.join(0.5)
        self.recordingStopped.emit()

    @pyqtSlot()
    def stop(self):
        self.interrupted = True


# We use snake case for the Qt-free part. Camel case is gross.
class RecorderProcess(multiprocessing.Process):

    # conn is the sending end of a multiprocessing.Pipe.
    def __init__(self, live_url, output_file, overwrite, conn):
        super().__init__()
        self.live_url = live_url
        self.output_file = output_file
        self.overwrite = overwrite
        self.conn = conn
        self.init_logger()

    def init_logger(self):
        self.logger = PipingLogger(self.conn, level=logging.INFO, **LOGGING_FORMATTER_OPTIONS)

    def run(self):
        stream_url, auto_filename_no_ext = self.fetch_stream_info(self.live_url)
        if not self.output_file:
            self.output_file = os.path.join(Config.downloadsDir, '%s.ts' % auto_filename_no_ext)

        self.logger.info('Output file: %s', self.output_file)
        self.record_stream(stream_url, self.output_file, overwrite=self.overwrite)

        self.conn.close()

    def log_command(self, cmd):
        msg = ' '.join(shlex.quote(arg) for arg in cmd)
        msg = msg.replace('%', '%%')
        self.logger.info(msg)

    # Handle output streams (stdout, stderr, or combined) of a
    # subprocess in real time, line by line, to depletion.
    #
    # The subprocess should be opened with bufsize=1 and
    # universal_newlines=True (text mode, line buffered).
    #
    # Credit: https://stackoverflow.com/a/4896288
    def handle_output(self, process, streams, handlers):
        def queue_up_read(fp, queue):
            for line in fp:
                queue.put(line)

        output_queues = [queue.Queue() for _ in streams]
        output_reader_threads = [threading.Thread(
            target=queue_up_read,
            args=(stream, output_queue),
            daemon=True,
        ) for stream, output_queue in zip(streams, output_queues)]
        for thread in output_reader_threads:
            thread.start()

        while process.poll() is None:
            no_output = True
            for output_queue, handler in zip(output_queues, handlers):
                try:
                    line = output_queue.get_nowait()
                except queue.Empty:
                    pass
                else:
                    no_output = False
                    handler(line)
            if no_output:
                time.sleep(0.01)

        # Process finished. Process remaining output.
        for output_queue, handle in zip(output_queues, handlers):
            while True:
                try:
                    line = output_queue.get_nowait()
                except queue.Empty:
                    break
                else:
                    handle(line)

    def fetch_stream_info(self, live_url):
        ytdl_cmd = ['youtube-dl', '--dump-json', '--youtube-skip-dash-manifest', live_url]
        self.log_command(ytdl_cmd)
        try:
            ytdl_process = None
            ytdl_process = subprocess.Popen(
                ytdl_cmd,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                **standard_subprocess_kwargs(),
            )
            ytdl_stdout_lines = []
            self.handle_output(ytdl_process, (ytdl_process.stdout, ytdl_process.stderr),
                               (ytdl_stdout_lines.append, self.conn.send))
            json_output = ''.join(ytdl_stdout_lines)
        except (OSError, subprocess.SubprocessError):
            if not ytdl_process:
                self.logger.error('Failed to start youtube-dl')
                sys.exit(1)
        if ytdl_process.returncode != 0:
            self.logger.error('youtube-dl failed with exit status %d', ytdl_process.returncode)
            sys.exit(1)

        try:
            metadata = json.loads(json_output)
        except json.JSONDecodeError as err:
            fd, path = tempfile.mkstemp()
            with os.fdopen(fd, 'w') as fp:
                fp.write(json_output)
            self.logger.error('Failed to decode JSON output: %s', err)
            self.logger.error('Response recorded to %s', path)
            sys.exit(1)

        try:
            if not metadata['is_live']:
                # Refuse to download a non-livestream.
                self.logger.error('Not a livestream.')
                sys.exit(1)
            format_id = metadata['format_id']
            for stream in metadata['formats']:
                if stream['format_id'] == format_id:
                    stream_url = stream['url']
                    protocol = stream['protocol']
                    if protocol != 'm3u8':
                        self.logger.warning('Unsupported protocol %s', protocol)
                    break
            else:
                self.logger.error('Format %s not found', format_id)
                sys.exit(1)
            auto_filename = metadata['_filename']
            auto_filename_no_ext = os.path.splitext(os.path.basename(auto_filename))[0]
        except (TypeError, KeyError):
            fd, path = tempfile.mkstemp()
            with os.fdopen(fd, 'w') as fp:
                fp.write(json_output)
            self.logger.error('JSON output does not contain the necessary information')
            self.logger.error('Response recorded to %s', path)
            sys.exit(1)

        return stream_url, auto_filename_no_ext

    def record_stream(self, stream_url, output_file, overwrite=False):
        os.makedirs(os.path.dirname(output_file), exist_ok=True)
        ffmpeg_cmd = ['ffmpeg', '-i', stream_url, '-c', 'copy', '-f', 'mpegts',
                      '-y' if overwrite else '-n', output_file]
        self.log_command(ffmpeg_cmd)
        try:
            ffmpeg_process = None
            ffmpeg_process = subprocess.Popen(
                ffmpeg_cmd,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                **standard_subprocess_kwargs(),
            )
            self.handle_output(ffmpeg_process, (ffmpeg_process.stdout,), (self.conn.send,))
        except (OSError, subprocess.SubprocessError):
            if not ffmpeg_process:
                self.logger.error('Failed to start ffmpeg')
                sys.exit(1)
        if ffmpeg_process.returncode != 0:
            self.logger.error('ffmpeg failed with exit status %d', ffmpeg_process.returncode)
            sys.exit(1)


class Printable(enum.Enum):
    PLAIN = 0
    HTML = 1


class SignalEmittingHandler(logging.Handler):

    # signal is a Worker.newMessage singal.
    def __init__(self, signal):
        super().__init__()
        self.signal = signal

    def emit(self, record):
        self.signal.emit(self.format(record) + '\n')


# A basic mock logger used in a RecorderProcess.
#
# We cannot use an actual logger (regardless of name passed to
# logging.getLogger), since on macOS, using the logger (e.g. calling
# logger.info) inside the forked process causes an error:
#
#   The process has forked and you cannot use this CoreFoundation functionality safely. You MUST exec().
#   Break on __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__() to debug.
#
# Possibly due to root logger interactions (just my guess).

class PipingLogger(object):

    _levelToName = {
        logging.CRITICAL: 'CRITICAL',
        logging.ERROR: 'ERROR',
        logging.WARNING: 'WARNING',
        logging.INFO: 'INFO',
        logging.DEBUG: 'DEBUG',
        logging.NOTSET: 'NOTSET',
    }

    # conn is the sending end of a multiprocessing.Pipe.
    #
    # fmt and datefmt are the same as the arguments to the logging.Formatter
    # constructor, except fmt only supports the %-style, and the following
    # attributes: asctime, levelname, and message.
    def __init__(self, conn, level=logging.INFO, fmt='', datefmt=''):
        self.conn = conn
        self.level = level
        self.fmt = fmt
        self.datefmt = datefmt

    def debug(self, msg, *args, **kwargs):
        self.log(logging.DEBUG, msg, *args, **kwargs)

    def info(self, msg, *args, **kwargs):
        self.log(logging.INFO, msg, *args, **kwargs)

    def warning(self, msg, *args, **kwargs):
        self.log(logging.WARNING, msg, *args, **kwargs)

    def error(self, msg, *args, **kwargs):
        self.log(logging.ERROR, msg, *args, **kwargs)

    def critical(self, msg, *args, **kwargs):
        self.log(logging.CRITICAL, msg, *args, **kwargs)

    # kwargs are ignored.
    def log(self, level, msg, *args, **kwargs):
        if level < self.level:
            return
        record = dict(
            asctime=time.strftime(self.datefmt),
            levelname=self._levelToName.get(level, 'UNKNOWN'),
            message=msg % args,
        )
        self.conn.send((self.fmt % record) + '\n')


if __name__ == '__main__':
    multiprocessing.freeze_support()
    window = MainWindow()
    app.aboutToQuit.connect(window.cleanUp)
    sys.exit(app.exec_())
